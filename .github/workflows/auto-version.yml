name: Perfect Auto SemVer

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  bump-version:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate and Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fullMessage = context.payload.head_commit.message;
            const lines = fullMessage.split('\n');
            const firstLine = lines[0].trim();
            const lowerFirstLine = firstLine.toLowerCase();

            let bumpType = null;
            if (lowerFirstLine.includes('major:')) bumpType = 'major';
            else if (lowerFirstLine.includes('minor:')) bumpType = 'minor';
            else if (lowerFirstLine.includes('patch:')) bumpType = 'patch';

            if (!bumpType) return;

            let cleanTitle = firstLine.replace(/^(major|minor|patch):\s*/i, '').trim();
            cleanTitle = cleanTitle.charAt(0).toUpperCase() + cleanTitle.slice(1);
            
            let lastTag = 'v0.0.0';
            try {
              let output = '';
              await exec.exec('git', ['describe', '--tags', '--abbrev=0'], {
                listeners: { stdout: (data) => { output += data.toString(); } }
              });
              lastTag = output.trim();
            } catch (e) {}

            let parts = lastTag.replace('v', '').split('.').map(num => parseInt(num, 10));
            if (parts.length < 3 || parts.some(isNaN)) parts = [0, 0, 0];
            let [major, minor, patch] = parts;

            if (bumpType === 'major') { major++; minor = 0; patch = 0; }
            else if (bumpType === 'minor') { minor++; patch = 0; }
            else if (bumpType === 'patch') { patch++; }

            const newVersion = `v${major}.${minor}.${patch}`;

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${newVersion}`,
                sha: context.sha
              });
            } catch (e) { return; }

            if (bumpType === 'major' || bumpType === 'minor') {
              // 1. --- Î•Î¥Î¡Î•Î£Î— Î¤ÎŸÎ¥ BASE TAG (v*.*.0) ---
              let baseTag = '';
              try {
                let baseOutput = '';
                // Î‘Î½Î±Î¶Î·Ï„Î¿ÏÎ¼Îµ Ï„Î¿ Ï€Î¹Î¿ Ï€ÏÏŒÏƒÏ†Î±Ï„Î¿ tag Ï€Î¿Ï… Ï„ÎµÎ»ÎµÎ¹ÏÎ½ÎµÎ¹ ÏƒÎµ .0
                await exec.exec('git', ['describe', '--tags', '--abbrev=0', '--match', 'v*.*.0'], {
                    listeners: { stdout: (data) => { baseOutput += data.toString(); } },
                    ignoreReturnCode: true 
                });
                baseTag = baseOutput.trim();
              } catch (e) {}
              
              // Î‘Î½ Î´ÎµÎ½ Î²ÏÎµÎ¹ .0 tag, Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ Î±Î¼Î­ÏƒÏ‰Ï‚ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿
              if (!baseTag) baseTag = lastTag; 

              let autoNotes = "";
              try {
                const response = await github.rest.repos.generateReleaseNotes({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: newVersion,
                  previous_tag_name: baseTag // Î•Î´Ï Î³Î¯Î½ÎµÏ„Î±Î¹ Î· ÏƒÏÎ³ÎºÏÎ¹ÏƒÎ· Î¼Îµ Ï„Î¿ .0 tag
                });
                autoNotes = response.data.body;
              } catch (e) {}

              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: newVersion,
                name: `${newVersion} - ${cleanTitle}`,
                body: `## ğŸš€ ${cleanTitle}\n\n` + autoNotes,
                generate_release_notes: false 
              });
            }
