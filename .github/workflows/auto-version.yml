name: Perfect Auto SemVer

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  bump-version:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate and Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fullMessage = context.payload.head_commit.message;
            const lines = fullMessage.split('\n');
            const firstLine = lines[0].trim();
            const lowerFirstLine = firstLine.toLowerCase();

            let bumpType = null;
            if (lowerFirstLine.includes('major:')) bumpType = 'major';
            else if (lowerFirstLine.includes('minor:')) bumpType = 'minor';
            else if (lowerFirstLine.includes('patch:')) bumpType = 'patch';

            if (!bumpType) return;

            let cleanTitle = firstLine.replace(/^(major|minor|patch):\s*/i, '').trim();
            cleanTitle = cleanTitle.charAt(0).toUpperCase() + cleanTitle.slice(1);
            
            let lastTag = 'v0.0.0';
            try {
              let output = '';
              await exec.exec('git', ['describe', '--tags', '--abbrev=0'], {
                listeners: { stdout: (data) => { output += data.toString(); } }
              });
              lastTag = output.trim();
            } catch (e) {}

            let parts = lastTag.replace('v', '').split('.').map(num => parseInt(num, 10));
            if (parts.length < 3 || parts.some(isNaN)) parts = [0, 0, 0];
            let [major, minor, patch] = parts;

            if (bumpType === 'major') { major++; minor = 0; patch = 0; }
            else if (bumpType === 'minor') { minor++; patch = 0; }
            else if (bumpType === 'patch') { patch++; }

            const newVersion = `v${major}.${minor}.${patch}`;

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${newVersion}`,
                sha: context.sha
              });
            } catch (e) { return; }

            if (bumpType === 'major' || bumpType === 'minor') {
              let autoNotes = "";
              try {
                const response = await github.rest.repos.generateReleaseNotes({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: newVersion,
                  previous_tag_name: lastTag 
                });
                autoNotes = response.data.body;
              } catch (e) {}

              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: newVersion,
                name: `${newVersion} - ${cleanTitle}`,
                body: `## ğŸš€ ${cleanTitle}\n\n` + autoNotes,
                generate_release_notes: false 
              });
            }
